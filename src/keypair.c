/*
 * Copyright (C) 2015 Mathias Brossard <mathias@brossard.org>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config.h"
#include "common.h"
#include "pkcs11_display.h"

#ifdef HAVE_OPENSSL
#include <openssl/evp.h>
#include <openssl/sha.h>
#include <openssl/ecdsa.h>
#endif

CK_RV setKeyId(CK_FUNCTION_LIST_PTR p11, CK_SESSION_HANDLE session,
               CK_OBJECT_HANDLE hPublicKey, CK_OBJECT_HANDLE hPrivateKey,
               CK_ATTRIBUTE_PTR attrs, CK_BYTE_PTR label)
{
	CK_RV rv = CKR_HOST_MEMORY;
    CK_BYTE buf[SHA_DIGEST_LENGTH];
    CK_ATTRIBUTE kid[2];
    int i = 0;

#ifdef HAVE_OPENSSL
    SHA1((unsigned char*)attrs[0].pValue, attrs[0].ulValueLen, buf);
    fillAttribute(&(kid[i++]), CKA_ID, buf, sizeof(buf));
#else
    /* If we don't have OpenSSL we use a part of the public key */
    int l = attrs[0].ulValueLen < SHA_DIGEST_LENGTH ?
        attrs[0].ulValueLen : SHA_DIGEST_LENGTH;
    int j = attrs[0].ulValueLen - l;
    fillAttribute(&(kid[i++]), CKA_ID, attrs[0].pValue + j, l);
#endif

    if(label) {
        fillAttribute(&(kid[i++]), CKA_LABEL, label, strlen((char *)label));
    }

    if(((rv = p11->C_SetAttributeValue(session, hPublicKey , kid, i)) != CKR_OK) ||
        ((rv = p11->C_SetAttributeValue(session, hPrivateKey, kid, i)) != CKR_OK)) {
        show_error(stdout, "C_SetAttributeValue", rv );
        return rv;
    }

	return rv;
}

CK_RV generateRsaKeyPair(CK_FUNCTION_LIST_PTR p11,
                         CK_SESSION_HANDLE session,
                         CK_ULONG size, CK_BYTE_PTR label)
{
	CK_RV rv = CKR_HOST_MEMORY;
    CK_OBJECT_HANDLE hPublicKey, hPrivateKey;
    CK_MECHANISM mechanism = { CKM_RSA_PKCS_KEY_PAIR_GEN, NULL_PTR, 0 };
    CK_BYTE exponent[3] = { 0x01, 0x00, 0x01 };
    CK_BBOOL t = TRUE;
    CK_ATTRIBUTE attrs[2];
    CK_OBJECT_CLASS	prv = CKO_PRIVATE_KEY;
    CK_OBJECT_CLASS pub = CKO_PUBLIC_KEY;
    CK_KEY_TYPE type = CKK_RSA;
    CK_ATTRIBUTE publicKeyTemplate[8] = {
        { CKA_CLASS ,          &pub,      sizeof(pub)      },
        { CKA_KEY_TYPE,        &type,     sizeof(type)     },
        { CKA_TOKEN,           &t,        sizeof(CK_BBOOL) },
        { CKA_ENCRYPT,         &t,        sizeof(CK_BBOOL) },
        { CKA_VERIFY,          &t,        sizeof(CK_BBOOL) },
        { CKA_WRAP,            &t,        sizeof(CK_BBOOL) },
        { CKA_MODULUS_BITS,    &size,     sizeof(size)     },
        { CKA_PUBLIC_EXPONENT, &exponent, sizeof(exponent) },
    };
    CK_ATTRIBUTE privateKeyTemplate[8] = {
        { CKA_CLASS,      &prv,       sizeof(prv)       },
        { CKA_KEY_TYPE,   &type,      sizeof(type)      },
        { CKA_TOKEN,      &t,         sizeof(CK_BBOOL)  },
        { CKA_PRIVATE,    &t,         sizeof(CK_BBOOL)  },
        { CKA_SENSITIVE,  &t,         sizeof(CK_BBOOL)  },
        { CKA_DECRYPT,    &t,         sizeof(CK_BBOOL)  },
        { CKA_SIGN,       &t,         sizeof(CK_BBOOL)  },
        { CKA_UNWRAP,     &t,         sizeof(CK_BBOOL)  },
    };

	if(!p11) {
        goto done;
    }

    if((rv = p11->C_GenerateKeyPair
        (session, &mechanism, publicKeyTemplate, 8,
         privateKeyTemplate, 8, &hPublicKey, &hPrivateKey)) != CKR_OK ) {
        show_error(stdout, "C_GenerateKeyPair", rv );
        goto done;
    }

    if((hPublicKey  == CK_INVALID_HANDLE) ||
       (hPrivateKey == CK_INVALID_HANDLE)) {
        rv = CKR_HOST_MEMORY; /* */
        show_error(stdout, "C_GenerateKeyPair", rv );
        goto done;
    }

    fillAttribute(&attrs[0], CKA_PUBLIC_EXPONENT, NULL, 0);
    fillAttribute(&attrs[1], CKA_MODULUS,         NULL, 0);

    if ((rv = p11->C_GetAttributeValue
         (session, hPublicKey, attrs, 2)) != CKR_OK) {
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }

    if (((attrs[0].pValue = malloc(attrs[0].ulValueLen)) == NULL) ||
        ((attrs[1].pValue = malloc(attrs[1].ulValueLen)) == NULL)) {
        rv = CKR_HOST_MEMORY;
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }

    if ((rv = p11->C_GetAttributeValue
         (session, hPublicKey, attrs, 2)) != CKR_OK) {
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }
#ifdef HAVE_OPENSSL
    rv = setKeyId(p11, session, hPublicKey, hPrivateKey, attrs, label);
#endif

 done:
	return rv;
}

static unsigned char prime256v1_oid[] = { 0x06, 0x08, 0x2a, 0x86, 0x48,
                                          0xce, 0x3d, 0x03, 0x01, 0x07 };
static unsigned char prime256v1_full[] =
    { 0x30,0x81,0xf7,0x02,0x01,0x01,0x30,0x2c,0x06,0x07,0x2a,0x86,0x48,0xce,0x3d,0x01,
      0x01,0x02,0x21,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0x30,0x5b,0x04,0x20,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x01,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x04,0x20,0x5a,0xc6,0x35,0xd8,0xaa,0x3a,
      0x93,0xe7,0xb3,0xeb,0xbd,0x55,0x76,0x98,0x86,0xbc,0x65,0x1d,0x06,0xb0,0xcc,0x53,
      0xb0,0xf6,0x3b,0xce,0x3c,0x3e,0x27,0xd2,0x60,0x4b,0x03,0x15,0x00,0xc4,0x9d,0x36,
      0x08,0x86,0xe7,0x04,0x93,0x6a,0x66,0x78,0xe1,0x13,0x9d,0x26,0xb7,0x81,0x9f,0x7e,
      0x90,0x04,0x41,0x04,0x6b,0x17,0xd1,0xf2,0xe1,0x2c,0x42,0x47,0xf8,0xbc,0xe6,0xe5,
      0x63,0xa4,0x40,0xf2,0x77,0x03,0x7d,0x81,0x2d,0xeb,0x33,0xa0,0xf4,0xa1,0x39,0x45,
      0xd8,0x98,0xc2,0x96,0x4f,0xe3,0x42,0xe2,0xfe,0x1a,0x7f,0x9b,0x8e,0xe7,0xeb,0x4a,
      0x7c,0x0f,0x9e,0x16,0x2b,0xce,0x33,0x57,0x6b,0x31,0x5e,0xce,0xcb,0xb6,0x40,0x68,
      0x37,0xbf,0x51,0xf5,0x02,0x21,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xbc,0xe6,0xfa,0xad,0xa7,0x17,0x9e,0x84,0xf3,
      0xb9,0xca,0xc2,0xfc,0x63,0x25,0x51,0x02,0x01,0x01 };

static unsigned char secp384r1_oid[] = { 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x22 };
static unsigned char secp384r1_full[] =
    { 0x30,0x82,0x01,0x57,0x02,0x01,0x01,0x30,0x3c,0x06,0x07,0x2a,0x86,0x48,0xce,0x3d,
      0x01,0x01,0x02,0x31,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0xff,0xff,0xff,0xff,0x30,0x7b,0x04,0x30,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xff,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xfc,0x04,0x30,0xb3,0x31,0x2f,0xa7,0xe2,
      0x3e,0xe7,0xe4,0x98,0x8e,0x05,0x6b,0xe3,0xf8,0x2d,0x19,0x18,0x1d,0x9c,0x6e,0xfe,
      0x81,0x41,0x12,0x03,0x14,0x08,0x8f,0x50,0x13,0x87,0x5a,0xc6,0x56,0x39,0x8d,0x8a,
      0x2e,0xd1,0x9d,0x2a,0x85,0xc8,0xed,0xd3,0xec,0x2a,0xef,0x03,0x15,0x00,0xa3,0x35,
      0x92,0x6a,0xa3,0x19,0xa2,0x7a,0x1d,0x00,0x89,0x6a,0x67,0x73,0xa4,0x82,0x7a,0xcd,
      0xac,0x73,0x04,0x61,0x04,0xaa,0x87,0xca,0x22,0xbe,0x8b,0x05,0x37,0x8e,0xb1,0xc7,
      0x1e,0xf3,0x20,0xad,0x74,0x6e,0x1d,0x3b,0x62,0x8b,0xa7,0x9b,0x98,0x59,0xf7,0x41,
      0xe0,0x82,0x54,0x2a,0x38,0x55,0x02,0xf2,0x5d,0xbf,0x55,0x29,0x6c,0x3a,0x54,0x5e,
      0x38,0x72,0x76,0x0a,0xb7,0x36,0x17,0xde,0x4a,0x96,0x26,0x2c,0x6f,0x5d,0x9e,0x98,
      0xbf,0x92,0x92,0xdc,0x29,0xf8,0xf4,0x1d,0xbd,0x28,0x9a,0x14,0x7c,0xe9,0xda,0x31,
      0x13,0xb5,0xf0,0xb8,0xc0,0x0a,0x60,0xb1,0xce,0x1d,0x7e,0x81,0x9d,0x7a,0x43,0x1d,
      0x7c,0x90,0xea,0x0e,0x5f,0x02,0x31,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xc7,0x63,0x4d,0x81,0xf4,0x37,0x2d,0xdf,0x58,0x1a,0x0d,0xb2,0x48,0xb0,0xa7,0x7a,
      0xec,0xec,0x19,0x6a,0xcc,0xc5,0x29,0x73,0x02,0x01,0x01 };

static unsigned char secp521r1_oid[] = { 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x23 };
static unsigned char secp521r1_full[] =
    { 0x30,0x82,0x01,0xc2,0x02,0x01,0x01,0x30,0x4d,0x06,0x07,0x2a,0x86,0x48,0xce,0x3d,
      0x01,0x01,0x02,0x42,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0x30,0x81,0x9e,0x04,0x42,0x01,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x04,0x41,0x51,
      0x95,0x3e,0xb9,0x61,0x8e,0x1c,0x9a,0x1f,0x92,0x9a,0x21,0xa0,0xb6,0x85,0x40,0xee,
      0xa2,0xda,0x72,0x5b,0x99,0xb3,0x15,0xf3,0xb8,0xb4,0x89,0x91,0x8e,0xf1,0x09,0xe1,
      0x56,0x19,0x39,0x51,0xec,0x7e,0x93,0x7b,0x16,0x52,0xc0,0xbd,0x3b,0xb1,0xbf,0x07,
      0x35,0x73,0xdf,0x88,0x3d,0x2c,0x34,0xf1,0xef,0x45,0x1f,0xd4,0x6b,0x50,0x3f,0x00,
      0x03,0x15,0x00,0xd0,0x9e,0x88,0x00,0x29,0x1c,0xb8,0x53,0x96,0xcc,0x67,0x17,0x39,
      0x32,0x84,0xaa,0xa0,0xda,0x64,0xba,0x04,0x81,0x85,0x04,0x00,0xc6,0x85,0x8e,0x06,
      0xb7,0x04,0x04,0xe9,0xcd,0x9e,0x3e,0xcb,0x66,0x23,0x95,0xb4,0x42,0x9c,0x64,0x81,
      0x39,0x05,0x3f,0xb5,0x21,0xf8,0x28,0xaf,0x60,0x6b,0x4d,0x3d,0xba,0xa1,0x4b,0x5e,
      0x77,0xef,0xe7,0x59,0x28,0xfe,0x1d,0xc1,0x27,0xa2,0xff,0xa8,0xde,0x33,0x48,0xb3,
      0xc1,0x85,0x6a,0x42,0x9b,0xf9,0x7e,0x7e,0x31,0xc2,0xe5,0xbd,0x66,0x01,0x18,0x39,
      0x29,0x6a,0x78,0x9a,0x3b,0xc0,0x04,0x5c,0x8a,0x5f,0xb4,0x2c,0x7d,0x1b,0xd9,0x98,
      0xf5,0x44,0x49,0x57,0x9b,0x44,0x68,0x17,0xaf,0xbd,0x17,0x27,0x3e,0x66,0x2c,0x97,
      0xee,0x72,0x99,0x5e,0xf4,0x26,0x40,0xc5,0x50,0xb9,0x01,0x3f,0xad,0x07,0x61,0x35,
      0x3c,0x70,0x86,0xa2,0x72,0xc2,0x40,0x88,0xbe,0x94,0x76,0x9f,0xd1,0x66,0x50,0x02,
      0x42,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
      0xff,0xff,0xfa,0x51,0x86,0x87,0x83,0xbf,0x2f,0x96,0x6b,0x7f,0xcc,0x01,0x48,0xf7,
      0x09,0xa5,0xd0,0x3b,0xb5,0xc9,0xb8,0x89,0x9c,0x47,0xae,0xbb,0x6f,0xb7,0x1e,0x91,
      0x38,0x64,0x09,0x02,0x01,0x01 };

CK_RV ecdsaNeedsEcParams(CK_FUNCTION_LIST *funcs,
                         CK_SLOT_ID slot_id, CK_BBOOL *full)
{
    CK_RV             rc;
    CK_MECHANISM_INFO minfo;

    rc = funcs->C_GetMechanismInfo(slot_id, CKM_EC_KEY_PAIR_GEN, &minfo);
    if(rc != CKR_OK) {
        show_error(stdout, "C_GetMechanismInfo", rc );
        goto done;
    }

    if(!(minfo.flags & CKF_EC_F_P)) {
        rc = CKR_DOMAIN_PARAMS_INVALID;
        show_error(stdout, "C_GetMechanismInfo", rc );
        goto done;
    }

    if(minfo.flags & (CKF_EC_ECPARAMETERS|CKF_EC_NAMEDCURVE)) {
        *full = minfo.flags & CKF_EC_NAMEDCURVE ? CK_FALSE : CK_TRUE;
    } else {
        rc = CKR_DOMAIN_PARAMS_INVALID;
    }

 done:
    return rc;
}

CK_RV generateEcdsaKeyPair(CK_FUNCTION_LIST_PTR p11,
                           CK_SESSION_HANDLE session,
                           char *name, CK_BBOOL full, CK_BYTE_PTR label)
{
	CK_RV rv = CKR_HOST_MEMORY;
    CK_OBJECT_HANDLE hPublicKey, hPrivateKey;
    CK_MECHANISM mechanism = { CKM_EC_KEY_PAIR_GEN, NULL_PTR, 0 };
    CK_BBOOL t = TRUE;
    CK_ATTRIBUTE attrs[1];
    CK_ATTRIBUTE pubTemplate[2] = {
        { CKA_EC_PARAMS,  NULL, 0                 },
        { CKA_TOKEN,      &t,   sizeof(CK_BBOOL)  }
    };
    CK_ATTRIBUTE privTemplate[4] = {
        { CKA_TOKEN,      &t,   sizeof(CK_BBOOL)  },
        { CKA_PRIVATE,    &t,   sizeof(CK_BBOOL)  },
        { CKA_SENSITIVE,  &t,   sizeof(CK_BBOOL)  },
        { CKA_SIGN,       &t,   sizeof(CK_BBOOL)  }
    };

	if(!p11) {
        goto done;
    }

    if(!name) {
        rv = CKR_DOMAIN_PARAMS_INVALID;
        goto done;
    } else if(!strcmp(name, "prime256v1") || !strcmp(name, "secp256r1") ||
              !strcmp(name, "nistp256") ||  !strcmp(name, "ansiX9p256r1")) {
        privTemplate[0].pValue = full ? prime256v1_full : prime256v1_oid;
        privTemplate[0].ulValueLen = full ?
            sizeof(prime256v1_full) : sizeof(prime256v1_oid);
    } else if(!strcmp(name, "secp384r1") || !strcmp(name, "prime384v1") ||
              !strcmp(name, "nistp384") || !strcmp(name, "ansiX9p384r1")) {
        privTemplate[0].pValue = full ? secp384r1_full : secp384r1_oid;
        privTemplate[0].ulValueLen = full ?
            sizeof(secp384r1_full) : sizeof(secp384r1_oid);
    } else if(!strcmp(name, "secp521r1") || !strcmp(name, "prime521v1") ||
              !strcmp(name, "nistp521") || !strcmp(name, "ansiX9p521r1")) {
        privTemplate[0].pValue = full ? secp521r1_full : secp521r1_oid;
        privTemplate[0].ulValueLen = full ?
            sizeof(secp521r1_full) : sizeof(secp521r1_oid);
    } else {
        rv = CKR_DOMAIN_PARAMS_INVALID;
        goto done;
    }
    pubTemplate[0].pValue = privTemplate[0].pValue;
    pubTemplate[0].ulValueLen = privTemplate[0].ulValueLen;

    if((rv = p11->C_GenerateKeyPair
        (session, &mechanism, pubTemplate, 2,
         privTemplate, 4, &hPublicKey, &hPrivateKey)) != CKR_OK ) {
        show_error(stdout, "C_GenerateKeyPair", rv );
        goto done;
    }

    if((hPublicKey  == CK_INVALID_HANDLE) ||
       (hPrivateKey == CK_INVALID_HANDLE)) {
        rv = CKR_HOST_MEMORY; /* Maybe there's something clearer */
        show_error(stdout, "C_GenerateKeyPair", rv );
        goto done;
    }

    fillAttribute(&attrs[0], CKA_EC_POINT, NULL, 0);
    if ((rv = p11->C_GetAttributeValue
         (session, hPublicKey, attrs, 1)) != CKR_OK) {
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }

    if (((attrs[0].pValue = malloc(attrs[0].ulValueLen)) == NULL)) {
        rv = CKR_HOST_MEMORY;
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }

    if ((rv = p11->C_GetAttributeValue
         (session, hPublicKey, attrs, 1)) != CKR_OK) {
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }

    /* print_generic(stdout, 0, attrs[0].pValue, attrs[0].ulValueLen, NULL); */

#ifdef HAVE_OPENSSL
    rv = setKeyId(p11, session, hPublicKey, hPrivateKey, attrs, label);
#endif

 done:
	return rv;
}

#define CKK_GOSTR3410              0x00000030
#define CKM_GOSTR3410_KEY_PAIR_GEN 0x00001200
#define CKA_GOSTR3410PARAMS        0x00000250

/* 1 2 643 2 2 35 0 */
static CK_BYTE gostR3410_params_0_oid[] =  { 0x06, 0x07, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x23, 0x00 };

/* 1 2 643 2 2 35 1 */
static CK_BYTE gostR3410_params_A_oid[] =  { 0x06, 0x07, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x23, 0x01 };

/* 1 2 643 2 2 35 2 */
static CK_BYTE gostR3410_params_B_oid[] =  { 0x06, 0x07, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x23, 0x02 };

/* 1 2 643 2 2 35 3 */
static CK_BYTE gostR3410_params_C_oid[] =  { 0x06, 0x07, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x23, 0x03 };

/* 1 2 643 2 2 36 1 */
static CK_BYTE gostR3410_params_XA_oid[] = { 0x06, 0x07, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x24, 0x01 };

/* 1 2 643 2 2 36 2 */
static CK_BYTE gostR3410_params_XB_oid[] = { 0x06, 0x07, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x24, 0x02 };

void gostEncryption(CK_ATTRIBUTE *pubTemplate, CK_ATTRIBUTE *privTemplate, CK_BBOOL *t, CK_BBOOL *f)
{
    pubTemplate[2].pValue = f;
    pubTemplate[3].pValue = t;
    pubTemplate[4].pValue = t;
    privTemplate[1].pValue = f;
    privTemplate[2].pValue = t;
    privTemplate[3].pValue = t;
}

CK_RV generateGostKeyPair(CK_FUNCTION_LIST_PTR p11,
                          CK_SESSION_HANDLE session,
                          char *name, CK_BYTE_PTR label)
{

	CK_RV rv = CKR_HOST_MEMORY;
    CK_OBJECT_HANDLE hPublicKey, hPrivateKey;
    CK_ATTRIBUTE attrs[1];

    CK_MECHANISM mechanism = { CKM_GOSTR3410_KEY_PAIR_GEN, NULL_PTR, 0 }; 
    CK_BBOOL t = TRUE;
    CK_BBOOL f = FALSE;
    CK_KEY_TYPE kt = CKK_GOSTR3410;
    CK_ATTRIBUTE pubTemplate[] = {
        { CKA_GOSTR3410PARAMS,     NULL, 9          },
        { CKA_KEY_TYPE,            &kt,  sizeof(kt) },
        { CKA_VERIFY,              &t,   sizeof(t)  },
        { CKA_ENCRYPT,             &f,   sizeof(f)  },
        { CKA_WRAP,                &f,   sizeof(f)  },
        { CKA_TOKEN,               &t,   sizeof(t)  }
    };

    CK_ATTRIBUTE privTemplate[] = {
        { CKA_KEY_TYPE,            &kt, sizeof(kt) },
        { CKA_SIGN,                &t,  sizeof(t)  },
        { CKA_DECRYPT,             &f,  sizeof(f)  },
        { CKA_UNWRAP,              &f,  sizeof(f)  },
        { CKA_SENSITIVE,           &t,  sizeof(t)  },
        { CKA_TOKEN,               &t,  sizeof(t)  },
        { CKA_PRIVATE,             &t,  sizeof(t)  },
        { CKA_EXTRACTABLE,         &f,  sizeof(f)  }
    };

	if(!p11) {
        goto done;
    }

    if(!name) {
        rv = CKR_DOMAIN_PARAMS_INVALID;
        goto done;
    } else if(!strcmp(name, "gost0") || !strcmp(name, "gostr3410-0")) {
        pubTemplate[0].pValue = gostR3410_params_0_oid;
    } else if(!strcmp(name, "gostA") || !strcmp(name, "gostr3410-A")) {
        pubTemplate[0].pValue = gostR3410_params_A_oid;
    } else if(!strcmp(name, "gostB") || !strcmp(name, "gostr3410-B")) {
        pubTemplate[0].pValue = gostR3410_params_B_oid;
    } else if(!strcmp(name, "gostC") || !strcmp(name, "gostr3410-C")) {
        pubTemplate[0].pValue = gostR3410_params_C_oid;
    } else if(!strcmp(name, "gostXA") || !strcmp(name, "gostr3410-XA")) {
        pubTemplate[0].pValue = gostR3410_params_XA_oid;
        gostEncryption(pubTemplate, privTemplate, &t, &f);
    } else if(!strcmp(name, "gostXB") || !strcmp(name, "gostr3410-XB")) {
        pubTemplate[0].pValue = gostR3410_params_XB_oid;
        gostEncryption(pubTemplate, privTemplate, &t, &f);
    } else {
        rv = CKR_DOMAIN_PARAMS_INVALID;
        goto done;
    }

    if((rv = p11->C_GenerateKeyPair
        (session, &mechanism, pubTemplate, 6,
         privTemplate, 8, &hPublicKey, &hPrivateKey)) != CKR_OK ) {
        show_error(stdout, "C_GenerateKeyPair", rv );
        goto done;
    }

    fprintf(stdout, "GOST R34.10-2001 Key generated\n");

    if((hPublicKey  == CK_INVALID_HANDLE) ||
       (hPrivateKey == CK_INVALID_HANDLE)) {
        rv = CKR_HOST_MEMORY; /* Maybe there's something clearer */
        show_error(stdout, "C_GenerateKeyPair", rv );
        goto done;
    }

    fillAttribute(&attrs[0], CKA_VALUE, NULL, 0);
    if ((rv = p11->C_GetAttributeValue
         (session, hPublicKey, attrs, 1)) != CKR_OK) {
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }

    if (((attrs[0].pValue = malloc(attrs[0].ulValueLen)) == NULL)) {
        rv = CKR_HOST_MEMORY;
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }

    if ((rv = p11->C_GetAttributeValue
         (session, hPublicKey, attrs, 1)) != CKR_OK) {
        show_error(stdout, "C_GetAttributeValue", rv );
        goto done;
    }

    rv = setKeyId(p11, session, hPublicKey, hPrivateKey, attrs, label);

 done:
	return rv;
}

